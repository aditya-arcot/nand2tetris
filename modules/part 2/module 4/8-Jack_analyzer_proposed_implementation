implementation plan
- JackTokenizer
- CompilationEngine
- JackAnalyzer (top-most module)


== JackAnalyzer ==
input
- fileName.jack
- directoryName

output
- if input is single file, fileName.xml
- if input is directory, one .xml file for every .jack file in directory

for each file
- create JackTokenizer from fileName.jack
- create output file named fileName.xml and prepares for writing
- creates and uses CompilationEngine to compile input JackTokenizer into output file
==========


== JackTokenizer ==
responsible for lexical elements

handles compiler's input

allows
- ignoring white space
- advancing input, 1 token at a time
- getting value and type of current token

API
constructor	
hasMoreTokens
advance
tokenType
keyword
symbol
identifier
intVal
stringVal
==========


== CompilationEngine ==
gets input from JackTokenizer and emits output to file

output generated by series of compilexxx routines
- one for (almost) every non-terminal rule xxx in grammar
- each responsible for handling all tokens that make up xxx
  - advances tokenizer exactly beyond these tokens
  - outputs parsing of xxx

following rules have no corresponding compilexxx methods
- type
- className
- subroutineName
- variableName
- statement
- subroutineCall

API
constructor
compileClass
compileClassVarDec
compileSubroutineDec
compileParameterList
compileSubroutineBody
compileVarDec
compileStatements
compileLet
compileIf
compileWhile
compileDo
compileReturn
compileExpression
compileTerm
compileExpressionList
==========

